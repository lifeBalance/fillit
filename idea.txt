TODO
====
1. check that last piece ends with a NEWLINE, not TWO! -> error
2. check that the MAXIMUM NUMBER OF PIECES is between 1 and 26! (if not -> error)
 
// check # or arguments: if not 1, print usage

// we created fillarray

// char *ln;
// gnl or streamlined version of it -> string of 4 -> ft_strlen > 4 BAIL
// every line is only 4 dots and ending with /n "4, 9, 14, " " . "  " "
// Validate if the dots are dots, and the amount of # is 4.
// if rows > 4 > BAIL


*block
if ft_strlen(line)
while if line[i] != . || #


int arr[4][4];
1 tetrimino = 4 x 4 = 16 ints = 16 x 32 bits = 512 bits

char arr[4][4];
1 tetrimino = 4 x 4 = 16 chars = 16  x 8 bits = 128 bits
1 tetrimino = 									 16 bits

ints:  40 tetriminos = 40 * 512 = 20048 bits
chars: 40 tetriminos = 40 * 128 =  5120 bits

40 tetriminos = 40 *  16 =   640 bits

1 tetrimino = 16 bits

....
###.
..#.
....

....
....
###.
..#.

4561321
.###
...#
....
....

....
.###
...#
....

456123
....
....
###.
..#.


4561890
###.
..#.
....
....

Storing stage
-------------
Unsigned short (2 bytes = 16 bits)

n: MSB 0000 0000 0010 1110 LSB (decimal 4561890)
                    ^

printf("%u", n); // 4561890

LSB	1110
	0010
	0000
	0000 MSB

(4561890) 0000 0000 0010 1110 = number (decimal 4561890)
stdint.h => uint16_t guarantees 16 bits

Setting a bit (turn on a bit - set its value to 1)
 mask: 0001 0000
          |
tmino: 0000 1010
  ret: 0001 1010

Testing a bit (turn on a bit - set its value to 1)
 mask: 1111 0000
          &
tmino: 0000 1010
  ret: 0000 0000

SHIFT PIECES
============
test_first_row() == 0
test_first_col() == 0

Shift the piece upwards and leftwards.

PRINTING STAGE
==============
0. Calculate and store piece dimensions
1. Calculate board dimensions based on piece dimensions
width:  2
height: 2


N = max(width, height)
N x N

widths:  2 + 2 = 4
heights: 4 + 4 = 8
//if the line is about to end and the piece has more stuff we skip the lineÂ§

w X h 
2   3
1   4
4   1
2   2
-----
9   10

max(9, 10) = 10

N x N
10x10

...........
...........
...........
...........
...........
...........
...........
...........
...........
...........

2 + 2 + 4 = 8
2 + 3 + 4 = 9 (bigger)

9 x 9

2. Copy the pieces to the board
AABB....
AABB....
........
........
........
........
........
........
........


Solution stage
--------------
#define L_ 	4561321
###
  #j

/struct s_tmino
{
	uint16_t	piece;
	char		letter;
}

switching map to bitwise
------------------------
AABB....
AABB....
CC.E....
.CEEE...
.C......

1100 1100 0000 0000
0000 1100 1100 0000
0000 1100 0100 0100
0000 1100 0100 0100


****************************************
16 uint16: uint16_t bitmap[16];

|1100 1100 0000 0000|
|1100 1100 0000 0000|
|1100 1100 0000 0000|
|1100 1100 0000 0000|
|1100 1100 0000 0000|
|1100 1100 0000 0000|
|1100 1100 0000 0000|
|1100 1100 0000 0000|
|1100 1100 0000 0000|
|1100 1100 0000 0000|
|1100 1100 0000 0000|
|1100 1100 0000 0000|
|1100 1100 0000 0000|
|1100 1100 0000 0000|
|1100 1100 0000 0000|
|0000 0000 0000 0000|

****************************************
4 uint64_t: uint64_t bitmap[4];

MSB (255)
255 % ... = 0-15
0 1 2 3 4 5 6 7 8 ... 15 (cols)

|1110 1110 1110 1110
 1110 1110 1110 1110
 0010 0010 0010 0010
 0010 0010 0010 0010|
|1110 1110 1110 1110
 1110 1110 1110 1110
 0010 0010 0010 0010
 0010 0010 0010 0010|
|1110 1110 1110 1110
 1110 1110 1110 1110
 0010 0010 0010 0010
 0010 0010 0010 0010|
|1110 1110 1110 1110
 1110 1110 1110 1110
 0010 0010 0010 0010
 0010 0010 0010 0010|

###.
..#.
....
....

LSB 0000 0000 MSB

................
#............... 2 width
................
#.#.............
................
................
................
#............... 7 height
................
................
................
................
................
................
................
................
